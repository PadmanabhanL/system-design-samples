# Findings: synchronized(this) vs synchronized(Inventory.class)

## Context
This summary is based on experiments with the `AtomicLimitationDemo` and `Inventory` classes, focusing on thread safety and locking mechanisms in Java.

## synchronized(this)
- **Scope:** Locks on the current instance of the object (`this`).
- **Effect:** Only threads accessing the same instance are synchronized. If multiple threads use different instances, they do **not** block each other.
- **Demo Result:** In the demo, each thread creates a new `Inventory` object. Thus, `synchronized(this)` does **not** provide effective synchronization across threads, as each thread locks a different object.
- **Use Case:** Useful when you want to synchronize access to instance-specific data and expect threads to share the same object.

## synchronized(Inventory.class)
- **Scope:** Locks on the `Inventory` class object (static lock).
- **Effect:** All threads, regardless of which `Inventory` instance they use, are synchronized. Only one thread can execute the synchronized block across all instances at a time.
- **Demo Result:** In the demo, even though each thread creates a new `Inventory` object, `synchronized(Inventory.class)` ensures that only one thread can enter the block at a time, providing effective synchronization.
- **Use Case:** Useful when you want to synchronize access to static/shared resources or ensure mutual exclusion across all instances of a class.

## Summary Table
| Lock Type                | Lock Scope         | Synchronizes Across Instances? | Demo Effectiveness |
|------------------------- |-------------------|-------------------------------|-------------------|
| `synchronized(this)`     | Instance          | No                            | Not effective     |
| `synchronized(Class)`    | Class (static)    | Yes                           | Effective         |

## Practical Implications
- Use `synchronized(this)` for instance-level locking when threads share the same object.
- Use `synchronized(Class)` for class-level locking when threads may use different instances but need mutual exclusion.
- In multi-threaded scenarios where each thread creates its own object, only class-level locking (`synchronized(Class)`) guarantees thread safety.

---
*Generated by GitHub Copilot based on your demo code and findings.*

